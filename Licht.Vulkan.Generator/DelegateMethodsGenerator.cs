using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics;
using static Licht.Vulkan.Generator.GeneratorUtilities;

namespace Licht.Vulkan.Generator;

[Generator]
public class DelegateMethodsGenerator : ISourceGenerator
{
    //language=csharp
    private const string DelegateMethodsAttribute = @"/// <auto-generated />
namespace Licht.Vulkan;

[AttributeUsage(AttributeTargets.Field)]
public class DelegateMethodsAttribute : Attribute {}
";
    private const string DelegateMethodsAttributeName = "Licht.Vulkan.DelegateMethodsAttribute";

    public void Initialize(GeneratorInitializationContext context)
    { 
        //register attribute
        context.RegisterForPostInitialization(ctx
            => ctx.AddSource("DelegateMethodsAttribute.g.cs", SourceText.From(DelegateMethodsAttribute, Encoding.UTF8)));
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());    
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
            return;

        var attributeSymbol = context.Compilation.GetTypeByMetadataName(DelegateMethodsAttributeName);
        foreach (var data in receiver.Fields.GroupByContainingType())
        {
            var classDef = data.Key;
            if (!classDef.ContainingSymbol.Equals(classDef.ContainingNamespace, SymbolEqualityComparer.Default)) return;
            var namespaceDef = data.Key.ToNamespaceString();
            var sb = new StringBuilder($@"using Silk.NET.Vulkan;
namespace {namespaceDef}
{{
    public partial class {classDef.Name}
    {{
");
            foreach(var field in data)
            {
                foreach (var method in field.Type.GetAllMethods()
                    .Where(m => m.MethodKind == MethodKind.Ordinary && m.Name != "Dispose"))
                {
                    var parameters = method.Parameters.ToList();
                    var parameterString = "";
                    var argumentString = "";
                    if (parameters.Count > 0)
                        (parameterString, argumentString) = ValidateParameters(classDef, parameters);
                    sb.AppendLine($"{Space(3)}public {method.ReturnType.ToDisplayString().Replace("Silk.NET.Vulkan.", "")} {method.Name}({parameterString}) => {field.Name}.{method.Name}({argumentString});");
                }
            }

            sb.Append($@"
    }}
}}");
            context.AddSource($"{classDef.Name}_generated.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    private (string, string) ValidateParameters(INamedTypeSymbol type, List<IParameterSymbol> parameters)
    {
        var args = parameters.BuildArgumentList();
        var fields = type.GetAllFields().Where(f => f.IsReadOnly); //get all readonly fields
        var indicesToSubstitute = new List<int>();
        var substituteFields = new List<IFieldSymbol>();
        for(var i = 0; i < parameters.Count; i++)
        {
            var ff = fields.FirstOrDefault(f => parameters[i].Type.Equals(f.Type, SymbolEqualityComparer.Default) && !parameters[i].HasExplicitDefaultValue);
            if (ff is not null)
            {
                indicesToSubstitute.Add(i);
                substituteFields.Add(ff);
            }
        }
        parameters.RemoveAll(p => indicesToSubstitute.Contains(parameters.IndexOf(p)));
        for(var i = 0; i < indicesToSubstitute.Count; i++) args[indicesToSubstitute[i]] = substituteFields[i].Name; 
        var parameterString = string.Join(", ", parameters.Select(s => s.RemoveNamespace("Silk.NET.Vulkan")));
        var argumentString = string.Join(", ", args);
        return (parameterString, argumentString);
    }

    class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<IFieldSymbol> Fields { get; } = new List<IFieldSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is FieldDeclarationSyntax fieldDeclarationSyntax
                && fieldDeclarationSyntax.AttributeLists.Count > 0)
            {
                foreach (VariableDeclaratorSyntax variable in fieldDeclarationSyntax.Declaration.Variables)
                {
                    var fieldSymbol = (IFieldSymbol)context.SemanticModel.GetDeclaredSymbol(variable)!;
                    if (fieldSymbol.HasAttribute(DelegateMethodsAttributeName))
                    {
                        Fields.Add(fieldSymbol);
                    }
                }
            }
        }
    }
}
